"use strict";
/// <reference path="./portable-fetch.d.ts" />
// tslint:disable
/**
 * YNAB API Endpoints
 * Our API uses a REST based design, leverages the JSON data format, and relies upon HTTPS for transport. We respond with meaningful HTTP response codes and if an error occurs, we include error details in the response body.  API Documentation is at https://api.youneedabudget.com
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
// Requiring portable-fetch like this ensures that we have a global fetch function
// That makes it easier to override with modules like fetch-mock
require("portable-fetch");
const USER_AGENT = "api_client/js/0.1.0";
function convertDateToFullDateStringFormat(date) {
    // Convert to RFC 3339 "full-date" format, like "2017-11-27"
    if (date instanceof Date) {
        return date.toISOString().substring(0, 10);
    }
    else {
        return date;
    }
}
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace Account
 */
var Account;
(function (Account) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["Checking"] = 'Checking'] = "Checking";
        TypeEnum[TypeEnum["Savings"] = 'Savings'] = "Savings";
        TypeEnum[TypeEnum["CreditCard"] = 'CreditCard'] = "CreditCard";
    })(TypeEnum = Account.TypeEnum || (Account.TypeEnum = {}));
})(Account = exports.Account || (exports.Account = {}));
/**
 * @export
 * @namespace ScheduledTransactionSummary
 */
var ScheduledTransactionSummary;
(function (ScheduledTransactionSummary) {
    /**
     * @export
     * @enum {string}
     */
    let FrequencyEnum;
    (function (FrequencyEnum) {
        FrequencyEnum[FrequencyEnum["Never"] = 'Never'] = "Never";
        FrequencyEnum[FrequencyEnum["Daily"] = 'Daily'] = "Daily";
        FrequencyEnum[FrequencyEnum["Weekly"] = 'Weekly'] = "Weekly";
        FrequencyEnum[FrequencyEnum["EveryOtherWeek"] = 'EveryOtherWeek'] = "EveryOtherWeek";
        FrequencyEnum[FrequencyEnum["TwiceAMonth"] = 'TwiceAMonth'] = "TwiceAMonth";
        FrequencyEnum[FrequencyEnum["Every4Weeks"] = 'Every4Weeks'] = "Every4Weeks";
        FrequencyEnum[FrequencyEnum["Monthly"] = 'Monthly'] = "Monthly";
        FrequencyEnum[FrequencyEnum["EveryOtherMonth"] = 'EveryOtherMonth'] = "EveryOtherMonth";
        FrequencyEnum[FrequencyEnum["Every3Months"] = 'Every3Months'] = "Every3Months";
        FrequencyEnum[FrequencyEnum["Every4Months"] = 'Every4Months'] = "Every4Months";
        FrequencyEnum[FrequencyEnum["TwiceAYear"] = 'TwiceAYear'] = "TwiceAYear";
        FrequencyEnum[FrequencyEnum["Yearly"] = 'Yearly'] = "Yearly";
        FrequencyEnum[FrequencyEnum["EveryOtherYear"] = 'EveryOtherYear'] = "EveryOtherYear";
    })(FrequencyEnum = ScheduledTransactionSummary.FrequencyEnum || (ScheduledTransactionSummary.FrequencyEnum = {}));
})(ScheduledTransactionSummary = exports.ScheduledTransactionSummary || (exports.ScheduledTransactionSummary = {}));
/**
 * @export
 * @namespace TransactionSummary
 */
var TransactionSummary;
(function (TransactionSummary) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'Cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'Uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'Reconciled'] = "Reconciled";
    })(ClearedEnum = TransactionSummary.ClearedEnum || (TransactionSummary.ClearedEnum = {}));
})(TransactionSummary = exports.TransactionSummary || (exports.TransactionSummary = {}));
/**
 * @export
 * @namespace ScheduledTransactionDetail
 */
var ScheduledTransactionDetail;
(function (ScheduledTransactionDetail) {
    /**
     * @export
     * @enum {string}
     */
    let FrequencyEnum;
    (function (FrequencyEnum) {
        FrequencyEnum[FrequencyEnum["Never"] = 'Never'] = "Never";
        FrequencyEnum[FrequencyEnum["Daily"] = 'Daily'] = "Daily";
        FrequencyEnum[FrequencyEnum["Weekly"] = 'Weekly'] = "Weekly";
        FrequencyEnum[FrequencyEnum["EveryOtherWeek"] = 'EveryOtherWeek'] = "EveryOtherWeek";
        FrequencyEnum[FrequencyEnum["TwiceAMonth"] = 'TwiceAMonth'] = "TwiceAMonth";
        FrequencyEnum[FrequencyEnum["Every4Weeks"] = 'Every4Weeks'] = "Every4Weeks";
        FrequencyEnum[FrequencyEnum["Monthly"] = 'Monthly'] = "Monthly";
        FrequencyEnum[FrequencyEnum["EveryOtherMonth"] = 'EveryOtherMonth'] = "EveryOtherMonth";
        FrequencyEnum[FrequencyEnum["Every3Months"] = 'Every3Months'] = "Every3Months";
        FrequencyEnum[FrequencyEnum["Every4Months"] = 'Every4Months'] = "Every4Months";
        FrequencyEnum[FrequencyEnum["TwiceAYear"] = 'TwiceAYear'] = "TwiceAYear";
        FrequencyEnum[FrequencyEnum["Yearly"] = 'Yearly'] = "Yearly";
        FrequencyEnum[FrequencyEnum["EveryOtherYear"] = 'EveryOtherYear'] = "EveryOtherYear";
    })(FrequencyEnum = ScheduledTransactionDetail.FrequencyEnum || (ScheduledTransactionDetail.FrequencyEnum = {}));
})(ScheduledTransactionDetail = exports.ScheduledTransactionDetail || (exports.ScheduledTransactionDetail = {}));
/**
 * @export
 * @namespace TransactionDetail
 */
var TransactionDetail;
(function (TransactionDetail) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'Cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'Uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'Reconciled'] = "Reconciled";
    })(ClearedEnum = TransactionDetail.ClearedEnum || (TransactionDetail.ClearedEnum = {}));
})(TransactionDetail = exports.TransactionDetail || (exports.TransactionDetail = {}));
/**
 * AccountsApi - fetch parameter creator
 * @export
 */
exports.AccountsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budgetId, accountId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getAccountById.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling getAccountById.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budgetId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getAccounts.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountsApi - functional programming interface
 * @export
 */
exports.AccountsApiFp = function (configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budgetId, accountId, options) {
            const localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).getAccountById(budgetId, accountId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budgetId, options) {
            const localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).getAccounts(budgetId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * AccountsApi - factory interface
 * @export
 */
exports.AccountsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budgetId, accountId, options) {
            return exports.AccountsApiFp(configuration).getAccountById(budgetId, accountId, options)();
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budgetId, options) {
            return exports.AccountsApiFp(configuration).getAccounts(budgetId, options)();
        },
    };
};
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends BaseAPI {
    /**
     * Returns a single account
     * @summary Single account
     * @param {string} budgetId - ID of budget
     * @param {string} accountId - ID of account
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccountById(budgetId, accountId, options) {
        return exports.AccountsApiFp(this.configuration).getAccountById(budgetId, accountId, options)();
    }
    /**
     * Returns all accounts
     * @summary Account list
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccounts(budgetId, options) {
        return exports.AccountsApiFp(this.configuration).getAccounts(budgetId, options)();
    }
}
exports.AccountsApi = AccountsApi;
/**
 * BudgetsApi - fetch parameter creator
 * @export
 */
exports.BudgetsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budgetId - ID of budget
         * @param {number} [lastKnowledgeOfServer] - Starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budgetId, lastKnowledgeOfServer, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getBudgetById.');
            }
            const localVarPath = `/budgets/{budget_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budgets list with summary information
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options = {}) {
            const localVarPath = `/budgets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BudgetsApi - functional programming interface
 * @export
 */
exports.BudgetsApiFp = function (configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budgetId - ID of budget
         * @param {number} [lastKnowledgeOfServer] - Starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budgetId, lastKnowledgeOfServer, options) {
            const localVarFetchArgs = exports.BudgetsApiFetchParamCreator(configuration).getBudgetById(budgetId, lastKnowledgeOfServer, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns budgets list with summary information
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options) {
            const localVarFetchArgs = exports.BudgetsApiFetchParamCreator(configuration).getBudgets(options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * BudgetsApi - factory interface
 * @export
 */
exports.BudgetsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budgetId - ID of budget
         * @param {number} [lastKnowledgeOfServer] - Starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budgetId, lastKnowledgeOfServer, options) {
            return exports.BudgetsApiFp(configuration).getBudgetById(budgetId, lastKnowledgeOfServer, options)();
        },
        /**
         * Returns budgets list with summary information
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options) {
            return exports.BudgetsApiFp(configuration).getBudgets(options)();
        },
    };
};
/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
class BudgetsApi extends BaseAPI {
    /**
     * Returns a single budget with all related entities.  This resource is effectively a full budget export.
     * @summary Single budget
     * @param {string} budgetId - ID of budget
     * @param {number} [lastKnowledgeOfServer] - Starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudgetById(budgetId, lastKnowledgeOfServer, options) {
        return exports.BudgetsApiFp(this.configuration).getBudgetById(budgetId, lastKnowledgeOfServer, options)();
    }
    /**
     * Returns budgets list with summary information
     * @summary List budgets
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudgets(options) {
        return exports.BudgetsApiFp(this.configuration).getBudgets(options)();
    }
}
exports.BudgetsApi = BudgetsApi;
/**
 * CategoriesApi - fetch parameter creator
 * @export
 */
exports.CategoriesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns all categories grouped by category group
         * @summary List categories
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budgetId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getCategories.');
            }
            const localVarPath = `/budgets/{budget_id}/categories`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single category
         * @summary Single category
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budgetId, categoryId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getCategoryById.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling getCategoryById.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CategoriesApi - functional programming interface
 * @export
 */
exports.CategoriesApiFp = function (configuration) {
    return {
        /**
         * Returns all categories grouped by category group
         * @summary List categories
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budgetId, options) {
            const localVarFetchArgs = exports.CategoriesApiFetchParamCreator(configuration).getCategories(budgetId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns a single category
         * @summary Single category
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budgetId, categoryId, options) {
            const localVarFetchArgs = exports.CategoriesApiFetchParamCreator(configuration).getCategoryById(budgetId, categoryId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * CategoriesApi - factory interface
 * @export
 */
exports.CategoriesApiFactory = function (configuration) {
    return {
        /**
         * Returns all categories grouped by category group
         * @summary List categories
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budgetId, options) {
            return exports.CategoriesApiFp(configuration).getCategories(budgetId, options)();
        },
        /**
         * Returns a single category
         * @summary Single category
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budgetId, categoryId, options) {
            return exports.CategoriesApiFp(configuration).getCategoryById(budgetId, categoryId, options)();
        },
    };
};
/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
class CategoriesApi extends BaseAPI {
    /**
     * Returns all categories grouped by category group
     * @summary List categories
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategories(budgetId, options) {
        return exports.CategoriesApiFp(this.configuration).getCategories(budgetId, options)();
    }
    /**
     * Returns a single category
     * @summary Single category
     * @param {string} budgetId - ID of budget
     * @param {string} categoryId - ID of category
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategoryById(budgetId, categoryId, options) {
        return exports.CategoriesApiFp(this.configuration).getCategoryById(budgetId, categoryId, options)();
    }
}
exports.CategoriesApi = CategoriesApi;
/**
 * MonthsApi - fetch parameter creator
 * @export
 */
exports.MonthsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budgetId - ID of budget
         * @param {Date} month - The budget month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budgetId, month, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getBudgetMonth.');
            }
            // verify required parameter 'month' is not null or undefined
            if (month === null || month === undefined) {
                throw new RequiredError('month', 'Required parameter month was null or undefined when calling getBudgetMonth.');
            }
            const localVarPath = `/budgets/{budget_id}/months/{month}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"month"}}`, encodeURIComponent(convertDateToFullDateStringFormat(month)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budgetId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getBudgetMonths.');
            }
            const localVarPath = `/budgets/{budget_id}/months`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MonthsApi - functional programming interface
 * @export
 */
exports.MonthsApiFp = function (configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budgetId - ID of budget
         * @param {Date} month - The budget month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budgetId, month, options) {
            const localVarFetchArgs = exports.MonthsApiFetchParamCreator(configuration).getBudgetMonth(budgetId, month, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budgetId, options) {
            const localVarFetchArgs = exports.MonthsApiFetchParamCreator(configuration).getBudgetMonths(budgetId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * MonthsApi - factory interface
 * @export
 */
exports.MonthsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budgetId - ID of budget
         * @param {Date} month - The budget month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budgetId, month, options) {
            return exports.MonthsApiFp(configuration).getBudgetMonth(budgetId, month, options)();
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budgetId, options) {
            return exports.MonthsApiFp(configuration).getBudgetMonths(budgetId, options)();
        },
    };
};
/**
 * MonthsApi - object-oriented interface
 * @export
 * @class MonthsApi
 * @extends {BaseAPI}
 */
class MonthsApi extends BaseAPI {
    /**
     * Returns a single budget month
     * @summary Single budget month
     * @param {string} budgetId - ID of budget
     * @param {Date} month - The budget month.  \"current\" can also be used to specify the current calendar month (UTC).
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    getBudgetMonth(budgetId, month, options) {
        return exports.MonthsApiFp(this.configuration).getBudgetMonth(budgetId, month, options)();
    }
    /**
     * Returns all budget months
     * @summary List budget months
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    getBudgetMonths(budgetId, options) {
        return exports.MonthsApiFp(this.configuration).getBudgetMonths(budgetId, options)();
    }
}
exports.MonthsApi = MonthsApi;
/**
 * PayeeLocationsApi - fetch parameter creator
 * @export
 */
exports.PayeeLocationsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budgetId - ID of budget
         * @param {string} payeeLocationId - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budgetId, payeeLocationId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getPayeeLocationById.');
            }
            // verify required parameter 'payeeLocationId' is not null or undefined
            if (payeeLocationId === null || payeeLocationId === undefined) {
                throw new RequiredError('payeeLocationId', 'Required parameter payeeLocationId was null or undefined when calling getPayeeLocationById.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations/{payee_location_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_location_id"}}`, encodeURIComponent(String(payeeLocationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budgetId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getPayeeLocations.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budgetId, payeeId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getPayeeLocationsByPayee.');
            }
            // verify required parameter 'payeeId' is not null or undefined
            if (payeeId === null || payeeId === undefined) {
                throw new RequiredError('payeeId', 'Required parameter payeeId was null or undefined when calling getPayeeLocationsByPayee.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payeeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PayeeLocationsApi - functional programming interface
 * @export
 */
exports.PayeeLocationsApiFp = function (configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budgetId - ID of budget
         * @param {string} payeeLocationId - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budgetId, payeeLocationId, options) {
            const localVarFetchArgs = exports.PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationById(budgetId, payeeLocationId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budgetId, options) {
            const localVarFetchArgs = exports.PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocations(budgetId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budgetId, payeeId, options) {
            const localVarFetchArgs = exports.PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationsByPayee(budgetId, payeeId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * PayeeLocationsApi - factory interface
 * @export
 */
exports.PayeeLocationsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budgetId - ID of budget
         * @param {string} payeeLocationId - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budgetId, payeeLocationId, options) {
            return exports.PayeeLocationsApiFp(configuration).getPayeeLocationById(budgetId, payeeLocationId, options)();
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budgetId, options) {
            return exports.PayeeLocationsApiFp(configuration).getPayeeLocations(budgetId, options)();
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budgetId, payeeId, options) {
            return exports.PayeeLocationsApiFp(configuration).getPayeeLocationsByPayee(budgetId, payeeId, options)();
        },
    };
};
/**
 * PayeeLocationsApi - object-oriented interface
 * @export
 * @class PayeeLocationsApi
 * @extends {BaseAPI}
 */
class PayeeLocationsApi extends BaseAPI {
    /**
     * Returns a single payee location
     * @summary Single payee location
     * @param {string} budgetId - ID of budget
     * @param {string} payeeLocationId - ID of payee location
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    getPayeeLocationById(budgetId, payeeLocationId, options) {
        return exports.PayeeLocationsApiFp(this.configuration).getPayeeLocationById(budgetId, payeeLocationId, options)();
    }
    /**
     * Returns all payee locations
     * @summary List payee locations
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    getPayeeLocations(budgetId, options) {
        return exports.PayeeLocationsApiFp(this.configuration).getPayeeLocations(budgetId, options)();
    }
    /**
     * Returns all payee locations for the specified payee
     * @summary List locations for a payee
     * @param {string} budgetId - ID of budget
     * @param {string} payeeId - ID of payee
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    getPayeeLocationsByPayee(budgetId, payeeId, options) {
        return exports.PayeeLocationsApiFp(this.configuration).getPayeeLocationsByPayee(budgetId, payeeId, options)();
    }
}
exports.PayeeLocationsApi = PayeeLocationsApi;
/**
 * PayeesApi - fetch parameter creator
 * @export
 */
exports.PayeesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budgetId, payeeId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getPayeeById.');
            }
            // verify required parameter 'payeeId' is not null or undefined
            if (payeeId === null || payeeId === undefined) {
                throw new RequiredError('payeeId', 'Required parameter payeeId was null or undefined when calling getPayeeById.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payeeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budgetId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getPayees.');
            }
            const localVarPath = `/budgets/{budget_id}/payees`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PayeesApi - functional programming interface
 * @export
 */
exports.PayeesApiFp = function (configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budgetId, payeeId, options) {
            const localVarFetchArgs = exports.PayeesApiFetchParamCreator(configuration).getPayeeById(budgetId, payeeId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budgetId, options) {
            const localVarFetchArgs = exports.PayeesApiFetchParamCreator(configuration).getPayees(budgetId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * PayeesApi - factory interface
 * @export
 */
exports.PayeesApiFactory = function (configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budgetId, payeeId, options) {
            return exports.PayeesApiFp(configuration).getPayeeById(budgetId, payeeId, options)();
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budgetId, options) {
            return exports.PayeesApiFp(configuration).getPayees(budgetId, options)();
        },
    };
};
/**
 * PayeesApi - object-oriented interface
 * @export
 * @class PayeesApi
 * @extends {BaseAPI}
 */
class PayeesApi extends BaseAPI {
    /**
     * Returns single payee
     * @summary Single payee
     * @param {string} budgetId - ID of budget
     * @param {string} payeeId - ID of payee
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    getPayeeById(budgetId, payeeId, options) {
        return exports.PayeesApiFp(this.configuration).getPayeeById(budgetId, payeeId, options)();
    }
    /**
     * Returns all payees
     * @summary List payees
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    getPayees(budgetId, options) {
        return exports.PayeesApiFp(this.configuration).getPayees(budgetId, options)();
    }
}
exports.PayeesApi = PayeesApi;
/**
 * ScheduledTransactionsApi - fetch parameter creator
 * @export
 */
exports.ScheduledTransactionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budgetId - ID of budget
         * @param {string} scheduledTransactionId - ID of scheduled transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budgetId, scheduledTransactionId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getScheduledTransactionById.');
            }
            // verify required parameter 'scheduledTransactionId' is not null or undefined
            if (scheduledTransactionId === null || scheduledTransactionId === undefined) {
                throw new RequiredError('scheduledTransactionId', 'Required parameter scheduledTransactionId was null or undefined when calling getScheduledTransactionById.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions/{scheduled_transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"scheduled_transaction_id"}}`, encodeURIComponent(String(scheduledTransactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budgetId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getScheduledTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ScheduledTransactionsApi - functional programming interface
 * @export
 */
exports.ScheduledTransactionsApiFp = function (configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budgetId - ID of budget
         * @param {string} scheduledTransactionId - ID of scheduled transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budgetId, scheduledTransactionId, options) {
            const localVarFetchArgs = exports.ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactionById(budgetId, scheduledTransactionId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budgetId, options) {
            const localVarFetchArgs = exports.ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactions(budgetId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * ScheduledTransactionsApi - factory interface
 * @export
 */
exports.ScheduledTransactionsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budgetId - ID of budget
         * @param {string} scheduledTransactionId - ID of scheduled transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budgetId, scheduledTransactionId, options) {
            return exports.ScheduledTransactionsApiFp(configuration).getScheduledTransactionById(budgetId, scheduledTransactionId, options)();
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budgetId, options) {
            return exports.ScheduledTransactionsApiFp(configuration).getScheduledTransactions(budgetId, options)();
        },
    };
};
/**
 * ScheduledTransactionsApi - object-oriented interface
 * @export
 * @class ScheduledTransactionsApi
 * @extends {BaseAPI}
 */
class ScheduledTransactionsApi extends BaseAPI {
    /**
     * Returns a single scheduled transaction
     * @summary Single scheduled transaction
     * @param {string} budgetId - ID of budget
     * @param {string} scheduledTransactionId - ID of scheduled transaction
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    getScheduledTransactionById(budgetId, scheduledTransactionId, options) {
        return exports.ScheduledTransactionsApiFp(this.configuration).getScheduledTransactionById(budgetId, scheduledTransactionId, options)();
    }
    /**
     * Returns all scheduled transactions
     * @summary List scheduled transactions
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    getScheduledTransactions(budgetId, options) {
        return exports.ScheduledTransactionsApiFp(this.configuration).getScheduledTransactions(budgetId, options)();
    }
}
exports.ScheduledTransactionsApi = ScheduledTransactionsApi;
/**
 * TransactionsApi - fetch parameter creator
 * @export
 */
exports.TransactionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns all budget transactions
         * @summary List transactions
         * @param {string} budgetId - ID of budget
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {string} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budgetId, sinceDate, type, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(sinceDate);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budgetId, accountId, sinceDate, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getTransactionsByAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId', 'Required parameter accountId was null or undefined when calling getTransactionsByAccount.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(sinceDate);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budgetId, categoryId, sinceDate, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getTransactionsByCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling getTransactionsByCategory.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(sinceDate);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budgetId - ID of budget
         * @param {string} transactionId - ID of transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budgetId, transactionId, options = {}) {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId', 'Required parameter budgetId was null or undefined when calling getTransactionsById.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling getTransactionsById.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
exports.TransactionsApiFp = function (configuration) {
    return {
        /**
         * Returns all budget transactions
         * @summary List transactions
         * @param {string} budgetId - ID of budget
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {string} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budgetId, sinceDate, type, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactions(budgetId, sinceDate, type, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budgetId, accountId, sinceDate, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsByAccount(budgetId, accountId, sinceDate, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budgetId, categoryId, sinceDate, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsByCategory(budgetId, categoryId, sinceDate, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budgetId - ID of budget
         * @param {string} transactionId - ID of transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budgetId, transactionId, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsById(budgetId, transactionId, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * TransactionsApi - factory interface
 * @export
 */
exports.TransactionsApiFactory = function (configuration) {
    return {
        /**
         * Returns all budget transactions
         * @summary List transactions
         * @param {string} budgetId - ID of budget
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {string} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budgetId, sinceDate, type, options) {
            return exports.TransactionsApiFp(configuration).getTransactions(budgetId, sinceDate, type, options)();
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budgetId, accountId, sinceDate, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsByAccount(budgetId, accountId, sinceDate, options)();
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budgetId, categoryId, sinceDate, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsByCategory(budgetId, categoryId, sinceDate, options)();
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budgetId - ID of budget
         * @param {string} transactionId - ID of transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budgetId, transactionId, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsById(budgetId, transactionId, options)();
        },
    };
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends BaseAPI {
    /**
     * Returns all budget transactions
     * @summary List transactions
     * @param {string} budgetId - ID of budget
     * @param {Date} [sinceDate] - Only return transactions on or after this date
     * @param {string} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactions(budgetId, sinceDate, type, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactions(budgetId, sinceDate, type, options)();
    }
    /**
     * Returns all transactions for a specified account
     * @summary List account transactions
     * @param {string} budgetId - ID of budget
     * @param {string} accountId - ID of account
     * @param {Date} [sinceDate] - Only return transactions on or after this date
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsByAccount(budgetId, accountId, sinceDate, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsByAccount(budgetId, accountId, sinceDate, options)();
    }
    /**
     * Returns all transactions for a specified category
     * @summary List category transactions
     * @param {string} budgetId - ID of budget
     * @param {string} categoryId - ID of category
     * @param {Date} [sinceDate] - Only return transactions on or after this date
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsByCategory(budgetId, categoryId, sinceDate, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsByCategory(budgetId, categoryId, sinceDate, options)();
    }
    /**
     * Returns a single transaction
     * @summary Single transaction
     * @param {string} budgetId - ID of budget
     * @param {string} transactionId - ID of transaction
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsById(budgetId, transactionId, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsById(budgetId, transactionId, options)();
    }
}
exports.TransactionsApi = TransactionsApi;
//# sourceMappingURL=api.js.map