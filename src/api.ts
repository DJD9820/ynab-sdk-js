/// <reference path="./portable-fetch.d.ts" />
// tslint:disable
/**
 * YNAB API Explorer
 * A read-only JSON / REST API to access YNAB budget data.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
// Requiring portable-fetch like this ensures that we have a global fetch function
// That makes it easier to override with modules like fetch-mock
require("portable-fetch");

import { Configuration } from "./configuration";

const BASE_PATH = "https://api.youneedabudget.com/v1/";

function convertDateToFullDateStringFormat(date: Date): string {
  // Convert to RFC 3339 "full-date" format, like "2017-11-27"
  return date.toISOString().substring(0, 10);
}

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetchFunction: FetchAPI = fetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    type: string;
    /**
     * Whether this account is on budget or not
     * @type {boolean}
     * @memberof Account
     */
    on_budget: boolean;
    /**
     * Whether this account is closed or not
     * @type {boolean}
     * @memberof Account
     */
    closed: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    note: string;
    /**
     * The current balance of the account in millicents format
     * @type {number}
     * @memberof Account
     */
    balance: number;
}

/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {AccountWrapper}
     * @memberof AccountResponse
     */
    data: AccountWrapper;
}

/**
 * 
 * @export
 * @interface AccountWrapper
 */
export interface AccountWrapper {
    /**
     * 
     * @type {Account}
     * @memberof AccountWrapper
     */
    account: Account;
}

/**
 * 
 * @export
 * @interface AccountsResponse
 */
export interface AccountsResponse {
    /**
     * 
     * @type {AccountsWrapper}
     * @memberof AccountsResponse
     */
    data: AccountsWrapper;
}

/**
 * 
 * @export
 * @interface AccountsWrapper
 */
export interface AccountsWrapper {
    /**
     * 
     * @type {Array&lt;Account&gt;}
     * @memberof AccountsWrapper
     */
    accounts: Array<Account>;
}

/**
 * 
 * @export
 * @interface BudgetDetailResponse
 */
export interface BudgetDetailResponse {
    /**
     * 
     * @type {BudgetDetailWrapper}
     * @memberof BudgetDetailResponse
     */
    data: BudgetDetailWrapper;
}

/**
 * 
 * @export
 * @interface BudgetDetailWrapper
 */
export interface BudgetDetailWrapper {
    /**
     * 
     * @type {BudgetDetail}
     * @memberof BudgetDetailWrapper
     */
    budget: BudgetDetail;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof BudgetDetailWrapper
     */
    server_knowledge: number;
}

/**
 * 
 * @export
 * @interface BudgetSummary
 */
export interface BudgetSummary {
    /**
     * 
     * @type {string}
     * @memberof BudgetSummary
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetSummary
     */
    last_accessed_on?: string;
    /**
     * 
     * @type {DateFormat}
     * @memberof BudgetSummary
     */
    date_format?: DateFormat;
    /**
     * 
     * @type {CurrencyFormat}
     * @memberof BudgetSummary
     */
    currency_format?: CurrencyFormat;
}

/**
 * 
 * @export
 * @interface BudgetSummaryResponse
 */
export interface BudgetSummaryResponse {
    /**
     * 
     * @type {BudgetSummaryWrapper}
     * @memberof BudgetSummaryResponse
     */
    data: BudgetSummaryWrapper;
}

/**
 * 
 * @export
 * @interface BudgetSummaryWrapper
 */
export interface BudgetSummaryWrapper {
    /**
     * 
     * @type {Array&lt;BudgetSummary&gt;}
     * @memberof BudgetSummaryWrapper
     */
    budgets: Array<BudgetSummary>;
}

/**
 * 
 * @export
 * @interface CategoriesResponse
 */
export interface CategoriesResponse {
    /**
     * 
     * @type {CategoryGroupsWrapper}
     * @memberof CategoriesResponse
     */
    data: CategoryGroupsWrapper;
}

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    category_group_id: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * Whether or not the category is hidden
     * @type {boolean}
     * @memberof Category
     */
    hidden: boolean;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    note: string;
    /**
     * Budgeted amount in current month in millicents format
     * @type {number}
     * @memberof Category
     */
    budgeted: number;
    /**
     * Activity amount in current month in millicents format
     * @type {number}
     * @memberof Category
     */
    activity: number;
    /**
     * Balance in current month in millicents format
     * @type {number}
     * @memberof Category
     */
    balance: number;
}

/**
 * 
 * @export
 * @interface CategoryGroup
 */
export interface CategoryGroup {
    /**
     * 
     * @type {string}
     * @memberof CategoryGroup
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryGroup
     */
    name: string;
    /**
     * Whether or not the category group is hidden
     * @type {boolean}
     * @memberof CategoryGroup
     */
    hidden: boolean;
}

/**
 * 
 * @export
 * @interface CategoryGroupsWrapper
 */
export interface CategoryGroupsWrapper {
    /**
     * 
     * @type {Array&lt;CategoryGroupWithCategories&gt;}
     * @memberof CategoryGroupsWrapper
     */
    category_groups: Array<CategoryGroupWithCategories>;
}

/**
 * 
 * @export
 * @interface CategoryResponse
 */
export interface CategoryResponse {
    /**
     * 
     * @type {CategoryWrapper}
     * @memberof CategoryResponse
     */
    data: CategoryWrapper;
}

/**
 * 
 * @export
 * @interface CategoryWrapper
 */
export interface CategoryWrapper {
    /**
     * 
     * @type {Category}
     * @memberof CategoryWrapper
     */
    category: Category;
}

/**
 * 
 * @export
 * @interface CurrencyFormat
 */
export interface CurrencyFormat {
    /**
     * 
     * @type {string}
     * @memberof CurrencyFormat
     */
    locale: string;
}

/**
 * 
 * @export
 * @interface DateFormat
 */
export interface DateFormat {
    /**
     * 
     * @type {string}
     * @memberof DateFormat
     */
    locale: string;
}

/**
 * 
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    description: string;
}

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorDetail}
     * @memberof ErrorResponse
     */
    error: ErrorDetail;
}

/**
 * 
 * @export
 * @interface MonthDetailResponse
 */
export interface MonthDetailResponse {
    /**
     * 
     * @type {MonthDetailWrapper}
     * @memberof MonthDetailResponse
     */
    data: MonthDetailWrapper;
}

/**
 * 
 * @export
 * @interface MonthDetailWrapper
 */
export interface MonthDetailWrapper {
    /**
     * 
     * @type {MonthDetail}
     * @memberof MonthDetailWrapper
     */
    month: MonthDetail;
}

/**
 * 
 * @export
 * @interface MonthSummariesResponse
 */
export interface MonthSummariesResponse {
    /**
     * 
     * @type {MonthSummariesWrapper}
     * @memberof MonthSummariesResponse
     */
    data: MonthSummariesWrapper;
}

/**
 * 
 * @export
 * @interface MonthSummariesWrapper
 */
export interface MonthSummariesWrapper {
    /**
     * 
     * @type {Array&lt;MonthSummary&gt;}
     * @memberof MonthSummariesWrapper
     */
    months: Array<MonthSummary>;
}

/**
 * 
 * @export
 * @interface MonthSummary
 */
export interface MonthSummary {
    /**
     * 
     * @type {string}
     * @memberof MonthSummary
     */
    month: string;
    /**
     * 
     * @type {string}
     * @memberof MonthSummary
     */
    note: string;
    /**
     * The current balance of the account in millicents format
     * @type {number}
     * @memberof MonthSummary
     */
    to_be_budgeted: number;
    /**
     * 
     * @type {number}
     * @memberof MonthSummary
     */
    age_of_money: number;
}

/**
 * 
 * @export
 * @interface Payee
 */
export interface Payee {
    /**
     * 
     * @type {string}
     * @memberof Payee
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Payee
     */
    name: string;
    /**
     * If a transfer payee, the account_id to which this payee transfers to
     * @type {string}
     * @memberof Payee
     */
    transfer_account_id: string;
}

/**
 * 
 * @export
 * @interface PayeeLocation
 */
export interface PayeeLocation {
    /**
     * 
     * @type {string}
     * @memberof PayeeLocation
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PayeeLocation
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof PayeeLocation
     */
    latitude: string;
    /**
     * 
     * @type {string}
     * @memberof PayeeLocation
     */
    longitude: string;
}

/**
 * 
 * @export
 * @interface PayeeLocationResponse
 */
export interface PayeeLocationResponse {
    /**
     * 
     * @type {PayeeLocationWrapper}
     * @memberof PayeeLocationResponse
     */
    data: PayeeLocationWrapper;
}

/**
 * 
 * @export
 * @interface PayeeLocationWrapper
 */
export interface PayeeLocationWrapper {
    /**
     * 
     * @type {PayeeLocation}
     * @memberof PayeeLocationWrapper
     */
    payee_location: PayeeLocation;
}

/**
 * 
 * @export
 * @interface PayeeLocationsResponse
 */
export interface PayeeLocationsResponse {
    /**
     * 
     * @type {PayeeLocationsWrapper}
     * @memberof PayeeLocationsResponse
     */
    data: PayeeLocationsWrapper;
}

/**
 * 
 * @export
 * @interface PayeeLocationsWrapper
 */
export interface PayeeLocationsWrapper {
    /**
     * 
     * @type {Array&lt;PayeeLocation&gt;}
     * @memberof PayeeLocationsWrapper
     */
    payee_locations: Array<PayeeLocation>;
}

/**
 * 
 * @export
 * @interface PayeeResponse
 */
export interface PayeeResponse {
    /**
     * 
     * @type {PayeeWrapper}
     * @memberof PayeeResponse
     */
    data: PayeeWrapper;
}

/**
 * 
 * @export
 * @interface PayeeWrapper
 */
export interface PayeeWrapper {
    /**
     * 
     * @type {Payee}
     * @memberof PayeeWrapper
     */
    payee: Payee;
}

/**
 * 
 * @export
 * @interface PayeesResponse
 */
export interface PayeesResponse {
    /**
     * 
     * @type {PayeesWrapper}
     * @memberof PayeesResponse
     */
    data: PayeesWrapper;
}

/**
 * 
 * @export
 * @interface PayeesWrapper
 */
export interface PayeesWrapper {
    /**
     * 
     * @type {Array&lt;Payee&gt;}
     * @memberof PayeesWrapper
     */
    payees: Array<Payee>;
}

/**
 * 
 * @export
 * @interface ScheduledSubTransaction
 */
export interface ScheduledSubTransaction {
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    scheduled_transaction_id: string;
    /**
     * The current balance of the account in millicents format
     * @type {number}
     * @memberof ScheduledSubTransaction
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    memo: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    category_id: string;
    /**
     * If a transfer, the account_id which the scheduled sub transaction transfers to
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    transfer_account_id: string;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionDetailResponse
 */
export interface ScheduledTransactionDetailResponse {
    /**
     * 
     * @type {ScheduledTransactionDetailWrapper}
     * @memberof ScheduledTransactionDetailResponse
     */
    data: ScheduledTransactionDetailWrapper;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionDetailWrapper
 */
export interface ScheduledTransactionDetailWrapper {
    /**
     * 
     * @type {ScheduledTransactionDetail}
     * @memberof ScheduledTransactionDetailWrapper
     */
    scheduled_transaction: ScheduledTransactionDetail;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionSummariesResponse
 */
export interface ScheduledTransactionSummariesResponse {
    /**
     * 
     * @type {ScheduledTransactionSummariesWrapper}
     * @memberof ScheduledTransactionSummariesResponse
     */
    data: ScheduledTransactionSummariesWrapper;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionSummariesWrapper
 */
export interface ScheduledTransactionSummariesWrapper {
    /**
     * 
     * @type {Array&lt;ScheduledTransactionSummary&gt;}
     * @memberof ScheduledTransactionSummariesWrapper
     */
    scheduled_transactions: Array<ScheduledTransactionSummary>;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionSummary
 */
export interface ScheduledTransactionSummary {
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    frequency: string;
    /**
     * The current balance of the account in millicents format
     * @type {number}
     * @memberof ScheduledTransactionSummary
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    memo: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    flag: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    category_id: string;
    /**
     * If a transfer, the account_id which the scheduled transaction transfers to
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    transfer_account_id: string;
}

/**
 * 
 * @export
 * @interface SubTransaction
 */
export interface SubTransaction {
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    transaction_id: string;
    /**
     * The current balance of the account in millicents format
     * @type {number}
     * @memberof SubTransaction
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    memo: string;
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    category_id: string;
    /**
     * If a transfer, the account_id which the subtransaction transfers to
     * @type {string}
     * @memberof SubTransaction
     */
    transfer_account_id: string;
}

/**
 * 
 * @export
 * @interface TransactionDetailResponse
 */
export interface TransactionDetailResponse {
    /**
     * 
     * @type {TransactionDetailWrapper}
     * @memberof TransactionDetailResponse
     */
    data: TransactionDetailWrapper;
}

/**
 * 
 * @export
 * @interface TransactionDetailWrapper
 */
export interface TransactionDetailWrapper {
    /**
     * 
     * @type {TransactionDetail}
     * @memberof TransactionDetailWrapper
     */
    transaction: TransactionDetail;
}

/**
 * 
 * @export
 * @interface TransactionSummariesResponse
 */
export interface TransactionSummariesResponse {
    /**
     * 
     * @type {TransactionSummariesWrapper}
     * @memberof TransactionSummariesResponse
     */
    data: TransactionSummariesWrapper;
}

/**
 * 
 * @export
 * @interface TransactionSummariesWrapper
 */
export interface TransactionSummariesWrapper {
    /**
     * 
     * @type {Array&lt;TransactionSummary&gt;}
     * @memberof TransactionSummariesWrapper
     */
    transactions: Array<TransactionSummary>;
}

/**
 * 
 * @export
 * @interface TransactionSummary
 */
export interface TransactionSummary {
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    date: string;
    /**
     * The current balance of the account in millicents format
     * @type {number}
     * @memberof TransactionSummary
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    memo: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof TransactionSummary
     */
    cleared: string;
    /**
     * Whether or not the transaction is approved
     * @type {boolean}
     * @memberof TransactionSummary
     */
    approved: boolean;
    /**
     * Whether or not the transaction is approved
     * @type {string}
     * @memberof TransactionSummary
     */
    flag: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    category_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    transfer_account_id: string;
}

/**
 * 
 * @export
 * @interface BudgetDetail
 */
export interface BudgetDetail {
    /**
     * 
     * @type {string}
     * @memberof BudgetDetail
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetDetail
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetDetail
     */
    last_accessed_on?: string;
    /**
     * 
     * @type {DateFormat}
     * @memberof BudgetDetail
     */
    date_format?: DateFormat;
    /**
     * 
     * @type {CurrencyFormat}
     * @memberof BudgetDetail
     */
    currency_format?: CurrencyFormat;
    /**
     * 
     * @type {Array&lt;Account&gt;}
     * @memberof BudgetDetail
     */
    accounts?: Array<Account>;
    /**
     * 
     * @type {Array&lt;Payee&gt;}
     * @memberof BudgetDetail
     */
    payees?: Array<Payee>;
    /**
     * 
     * @type {Array&lt;PayeeLocation&gt;}
     * @memberof BudgetDetail
     */
    payee_locations?: Array<PayeeLocation>;
    /**
     * 
     * @type {Array&lt;CategoryGroup&gt;}
     * @memberof BudgetDetail
     */
    category_groups?: Array<CategoryGroup>;
    /**
     * 
     * @type {Array&lt;Category&gt;}
     * @memberof BudgetDetail
     */
    categories?: Array<Category>;
    /**
     * 
     * @type {Array&lt;MonthDetail&gt;}
     * @memberof BudgetDetail
     */
    months?: Array<MonthDetail>;
    /**
     * 
     * @type {Array&lt;TransactionSummary&gt;}
     * @memberof BudgetDetail
     */
    transactions?: Array<TransactionSummary>;
    /**
     * 
     * @type {Array&lt;SubTransaction&gt;}
     * @memberof BudgetDetail
     */
    subtransactions?: Array<SubTransaction>;
    /**
     * 
     * @type {Array&lt;ScheduledTransactionSummary&gt;}
     * @memberof BudgetDetail
     */
    scheduled_transactions?: Array<ScheduledTransactionSummary>;
    /**
     * 
     * @type {Array&lt;ScheduledSubTransaction&gt;}
     * @memberof BudgetDetail
     */
    scheduled_subtransactions?: Array<ScheduledSubTransaction>;
}

/**
 * 
 * @export
 * @interface CategoryGroupWithCategories
 */
export interface CategoryGroupWithCategories {
    /**
     * 
     * @type {string}
     * @memberof CategoryGroupWithCategories
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryGroupWithCategories
     */
    name: string;
    /**
     * Whether or not the category group is hidden
     * @type {boolean}
     * @memberof CategoryGroupWithCategories
     */
    hidden: boolean;
    /**
     * Category group categories
     * @type {Array&lt;Category&gt;}
     * @memberof CategoryGroupWithCategories
     */
    categories: Array<Category>;
}

/**
 * 
 * @export
 * @interface MonthDetail
 */
export interface MonthDetail {
    /**
     * 
     * @type {string}
     * @memberof MonthDetail
     */
    month: string;
    /**
     * 
     * @type {string}
     * @memberof MonthDetail
     */
    note: string;
    /**
     * The current balance of the account in millicents format
     * @type {number}
     * @memberof MonthDetail
     */
    to_be_budgeted: number;
    /**
     * 
     * @type {number}
     * @memberof MonthDetail
     */
    age_of_money: number;
    /**
     * The budget month categories
     * @type {Array&lt;Category&gt;}
     * @memberof MonthDetail
     */
    categories: Array<Category>;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionDetail
 */
export interface ScheduledTransactionDetail {
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    frequency: string;
    /**
     * The current balance of the account in millicents format
     * @type {number}
     * @memberof ScheduledTransactionDetail
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    memo: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    flag: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    category_id: string;
    /**
     * If a transfer, the account_id which the scheduled transaction transfers to
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    transfer_account_id: string;
    /**
     * If a split scheduled transaction, the sub-transactions.
     * @type {Array&lt;ScheduledSubTransaction&gt;}
     * @memberof ScheduledTransactionDetail
     */
    subtransactions: Array<ScheduledSubTransaction>;
}

/**
 * 
 * @export
 * @interface TransactionDetail
 */
export interface TransactionDetail {
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    date: string;
    /**
     * The current balance of the account in millicents format
     * @type {number}
     * @memberof TransactionDetail
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    memo: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof TransactionDetail
     */
    cleared: string;
    /**
     * Whether or not the transaction is approved
     * @type {boolean}
     * @memberof TransactionDetail
     */
    approved: boolean;
    /**
     * Whether or not the transaction is approved
     * @type {string}
     * @memberof TransactionDetail
     */
    flag: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    category_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    transfer_account_id: string;
    /**
     * If a split transaction, the sub-transactions.
     * @type {Array&lt;SubTransaction&gt;}
     * @memberof TransactionDetail
     */
    subtransactions: Array<SubTransaction>;
}


/**
 * AccountsApi - fetch parameter creator
 * @export
 */
export const AccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find a single account by ID 
         * @summary Single account
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budgetId: string, accountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getAccountById.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountById.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all accounts 
         * @summary List accounts
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budgetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getAccounts.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find a single account by ID 
         * @summary Single account
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budgetId: string, accountId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<AccountResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getAccountById(budgetId, accountId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * List all accounts 
         * @summary List accounts
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budgetId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<AccountsResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getAccounts(budgetId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, fetchFunction?: FetchAPI, basePath?: string) {
    return {
        /**
         * Find a single account by ID 
         * @summary Single account
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budgetId: string, accountId: string, options?: any) {
            return AccountsApiFp(configuration).getAccountById(budgetId, accountId, options)(fetchFunction, basePath);
        },
        /**
         * List all accounts 
         * @summary List accounts
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budgetId: string, options?: any) {
            return AccountsApiFp(configuration).getAccounts(budgetId, options)(fetchFunction, basePath);
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Find a single account by ID 
     * @summary Single account
     * @param {string} budgetId - ID of budget
     * @param {string} accountId - ID of account
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountById(budgetId: string, accountId: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountById(budgetId, accountId, options)(this.fetchFunction, this.basePath);
    }

    /**
     * List all accounts 
     * @summary List accounts
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(budgetId: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccounts(budgetId, options)(this.fetchFunction, this.basePath);
    }

}

/**
 * BudgetsApi - fetch parameter creator
 * @export
 */
export const BudgetsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Single budget detail 
         * @summary Single budget
         * @param {string} budgetId - ID of budget
         * @param {number} [lastKnowledgeOfServer] - Starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetContents(budgetId: string, lastKnowledgeOfServer?: number, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getBudgetContents.');
            }
            const localVarPath = `/budgets/{budget_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all budgets 
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options: any = {}): FetchArgs {
            const localVarPath = `/budgets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetsApi - functional programming interface
 * @export
 */
export const BudgetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Single budget detail 
         * @summary Single budget
         * @param {string} budgetId - ID of budget
         * @param {number} [lastKnowledgeOfServer] - Starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetContents(budgetId: string, lastKnowledgeOfServer?: number, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<BudgetDetailResponse> {
            const localVarFetchArgs = BudgetsApiFetchParamCreator(configuration).getBudgetContents(budgetId, lastKnowledgeOfServer, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * List all budgets 
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<BudgetSummaryResponse> {
            const localVarFetchArgs = BudgetsApiFetchParamCreator(configuration).getBudgets(options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * BudgetsApi - factory interface
 * @export
 */
export const BudgetsApiFactory = function (configuration?: Configuration, fetchFunction?: FetchAPI, basePath?: string) {
    return {
        /**
         * Single budget detail 
         * @summary Single budget
         * @param {string} budgetId - ID of budget
         * @param {number} [lastKnowledgeOfServer] - Starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetContents(budgetId: string, lastKnowledgeOfServer?: number, options?: any) {
            return BudgetsApiFp(configuration).getBudgetContents(budgetId, lastKnowledgeOfServer, options)(fetchFunction, basePath);
        },
        /**
         * List all budgets 
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options?: any) {
            return BudgetsApiFp(configuration).getBudgets(options)(fetchFunction, basePath);
        },
    };
};

/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
export class BudgetsApi extends BaseAPI {
    /**
     * Single budget detail 
     * @summary Single budget
     * @param {string} budgetId - ID of budget
     * @param {number} [lastKnowledgeOfServer] - Starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgetContents(budgetId: string, lastKnowledgeOfServer?: number, options?: any) {
        return BudgetsApiFp(this.configuration).getBudgetContents(budgetId, lastKnowledgeOfServer, options)(this.fetchFunction, this.basePath);
    }

    /**
     * List all budgets 
     * @summary List budgets
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgets(options?: any) {
        return BudgetsApiFp(this.configuration).getBudgets(options)(this.fetchFunction, this.basePath);
    }

}

/**
 * CategoriesApi - fetch parameter creator
 * @export
 */
export const CategoriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all category groups 
         * @summary List category groups
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budgetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getCategories.');
            }
            const localVarPath = `/budgets/{budget_id}/categories`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a category by ID 
         * @summary Single category
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budgetId: string, categoryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getCategoryById.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getCategoryById.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all category groups 
         * @summary List category groups
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budgetId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<CategoriesResponse> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).getCategories(budgetId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Find a category by ID 
         * @summary Single category
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budgetId: string, categoryId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<CategoryResponse> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).getCategoryById(budgetId, categoryId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, fetchFunction?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all category groups 
         * @summary List category groups
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budgetId: string, options?: any) {
            return CategoriesApiFp(configuration).getCategories(budgetId, options)(fetchFunction, basePath);
        },
        /**
         * Find a category by ID 
         * @summary Single category
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budgetId: string, categoryId: string, options?: any) {
            return CategoriesApiFp(configuration).getCategoryById(budgetId, categoryId, options)(fetchFunction, basePath);
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * List all category groups 
     * @summary List category groups
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategories(budgetId: string, options?: any) {
        return CategoriesApiFp(this.configuration).getCategories(budgetId, options)(this.fetchFunction, this.basePath);
    }

    /**
     * Find a category by ID 
     * @summary Single category
     * @param {string} budgetId - ID of budget
     * @param {string} categoryId - ID of category
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategoryById(budgetId: string, categoryId: string, options?: any) {
        return CategoriesApiFp(this.configuration).getCategoryById(budgetId, categoryId, options)(this.fetchFunction, this.basePath);
    }

}

/**
 * MonthsApi - fetch parameter creator
 * @export
 */
export const MonthsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find a single budget month 
         * @summary Single budget month
         * @param {string} budgetId - ID of budget
         * @param {Date} month - The budget month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budgetId: string, month: Date, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getBudgetMonth.');
            }
            // verify required parameter 'month' is not null or undefined
            if (month === null || month === undefined) {
                throw new RequiredError('month','Required parameter month was null or undefined when calling getBudgetMonth.');
            }
            const localVarPath = `/budgets/{budget_id}/months/{month}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"month"}}`, encodeURIComponent(convertDateToFullDateStringFormat(month)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all budget months 
         * @summary List budget months
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budgetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getBudgetMonths.');
            }
            const localVarPath = `/budgets/{budget_id}/months`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonthsApi - functional programming interface
 * @export
 */
export const MonthsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find a single budget month 
         * @summary Single budget month
         * @param {string} budgetId - ID of budget
         * @param {Date} month - The budget month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budgetId: string, month: Date, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<MonthDetailResponse> {
            const localVarFetchArgs = MonthsApiFetchParamCreator(configuration).getBudgetMonth(budgetId, month, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * List all budget months 
         * @summary List budget months
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budgetId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<MonthSummariesResponse> {
            const localVarFetchArgs = MonthsApiFetchParamCreator(configuration).getBudgetMonths(budgetId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * MonthsApi - factory interface
 * @export
 */
export const MonthsApiFactory = function (configuration?: Configuration, fetchFunction?: FetchAPI, basePath?: string) {
    return {
        /**
         * Find a single budget month 
         * @summary Single budget month
         * @param {string} budgetId - ID of budget
         * @param {Date} month - The budget month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budgetId: string, month: Date, options?: any) {
            return MonthsApiFp(configuration).getBudgetMonth(budgetId, month, options)(fetchFunction, basePath);
        },
        /**
         * List all budget months 
         * @summary List budget months
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budgetId: string, options?: any) {
            return MonthsApiFp(configuration).getBudgetMonths(budgetId, options)(fetchFunction, basePath);
        },
    };
};

/**
 * MonthsApi - object-oriented interface
 * @export
 * @class MonthsApi
 * @extends {BaseAPI}
 */
export class MonthsApi extends BaseAPI {
    /**
     * Find a single budget month 
     * @summary Single budget month
     * @param {string} budgetId - ID of budget
     * @param {Date} month - The budget month.  \"current\" can also be used to specify the current calendar month (UTC).
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    public getBudgetMonth(budgetId: string, month: Date, options?: any) {
        return MonthsApiFp(this.configuration).getBudgetMonth(budgetId, month, options)(this.fetchFunction, this.basePath);
    }

    /**
     * List all budget months 
     * @summary List budget months
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    public getBudgetMonths(budgetId: string, options?: any) {
        return MonthsApiFp(this.configuration).getBudgetMonths(budgetId, options)(this.fetchFunction, this.basePath);
    }

}

/**
 * PayeeLocationsApi - fetch parameter creator
 * @export
 */
export const PayeeLocationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find a single payee location by ID 
         * @summary Single payee location
         * @param {string} budgetId - ID of budget
         * @param {string} payeeLocationId - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budgetId: string, payeeLocationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getPayeeLocationById.');
            }
            // verify required parameter 'payeeLocationId' is not null or undefined
            if (payeeLocationId === null || payeeLocationId === undefined) {
                throw new RequiredError('payeeLocationId','Required parameter payeeLocationId was null or undefined when calling getPayeeLocationById.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations/{payee_location_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_location_id"}}`, encodeURIComponent(String(payeeLocationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all payee locations 
         * @summary List payee locations
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budgetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getPayeeLocations.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List payee locations for a specified payee 
         * @summary List locations for a payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budgetId: string, payeeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getPayeeLocationsByPayee.');
            }
            // verify required parameter 'payeeId' is not null or undefined
            if (payeeId === null || payeeId === undefined) {
                throw new RequiredError('payeeId','Required parameter payeeId was null or undefined when calling getPayeeLocationsByPayee.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payeeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayeeLocationsApi - functional programming interface
 * @export
 */
export const PayeeLocationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find a single payee location by ID 
         * @summary Single payee location
         * @param {string} budgetId - ID of budget
         * @param {string} payeeLocationId - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budgetId: string, payeeLocationId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<PayeeLocationResponse> {
            const localVarFetchArgs = PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationById(budgetId, payeeLocationId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * List all payee locations 
         * @summary List payee locations
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budgetId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<PayeeLocationsResponse> {
            const localVarFetchArgs = PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocations(budgetId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * List payee locations for a specified payee 
         * @summary List locations for a payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budgetId: string, payeeId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<PayeeLocationsResponse> {
            const localVarFetchArgs = PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationsByPayee(budgetId, payeeId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * PayeeLocationsApi - factory interface
 * @export
 */
export const PayeeLocationsApiFactory = function (configuration?: Configuration, fetchFunction?: FetchAPI, basePath?: string) {
    return {
        /**
         * Find a single payee location by ID 
         * @summary Single payee location
         * @param {string} budgetId - ID of budget
         * @param {string} payeeLocationId - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budgetId: string, payeeLocationId: string, options?: any) {
            return PayeeLocationsApiFp(configuration).getPayeeLocationById(budgetId, payeeLocationId, options)(fetchFunction, basePath);
        },
        /**
         * List all payee locations 
         * @summary List payee locations
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budgetId: string, options?: any) {
            return PayeeLocationsApiFp(configuration).getPayeeLocations(budgetId, options)(fetchFunction, basePath);
        },
        /**
         * List payee locations for a specified payee 
         * @summary List locations for a payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budgetId: string, payeeId: string, options?: any) {
            return PayeeLocationsApiFp(configuration).getPayeeLocationsByPayee(budgetId, payeeId, options)(fetchFunction, basePath);
        },
    };
};

/**
 * PayeeLocationsApi - object-oriented interface
 * @export
 * @class PayeeLocationsApi
 * @extends {BaseAPI}
 */
export class PayeeLocationsApi extends BaseAPI {
    /**
     * Find a single payee location by ID 
     * @summary Single payee location
     * @param {string} budgetId - ID of budget
     * @param {string} payeeLocationId - ID of payee location
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    public getPayeeLocationById(budgetId: string, payeeLocationId: string, options?: any) {
        return PayeeLocationsApiFp(this.configuration).getPayeeLocationById(budgetId, payeeLocationId, options)(this.fetchFunction, this.basePath);
    }

    /**
     * List all payee locations 
     * @summary List payee locations
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    public getPayeeLocations(budgetId: string, options?: any) {
        return PayeeLocationsApiFp(this.configuration).getPayeeLocations(budgetId, options)(this.fetchFunction, this.basePath);
    }

    /**
     * List payee locations for a specified payee 
     * @summary List locations for a payee
     * @param {string} budgetId - ID of budget
     * @param {string} payeeId - ID of payee
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    public getPayeeLocationsByPayee(budgetId: string, payeeId: string, options?: any) {
        return PayeeLocationsApiFp(this.configuration).getPayeeLocationsByPayee(budgetId, payeeId, options)(this.fetchFunction, this.basePath);
    }

}

/**
 * PayeesApi - fetch parameter creator
 * @export
 */
export const PayeesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find a single payee by ID 
         * @summary Single payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budgetId: string, payeeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getPayeeById.');
            }
            // verify required parameter 'payeeId' is not null or undefined
            if (payeeId === null || payeeId === undefined) {
                throw new RequiredError('payeeId','Required parameter payeeId was null or undefined when calling getPayeeById.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payeeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all payees 
         * @summary List payees
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budgetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getPayees.');
            }
            const localVarPath = `/budgets/{budget_id}/payees`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayeesApi - functional programming interface
 * @export
 */
export const PayeesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find a single payee by ID 
         * @summary Single payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budgetId: string, payeeId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<PayeeResponse> {
            const localVarFetchArgs = PayeesApiFetchParamCreator(configuration).getPayeeById(budgetId, payeeId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * List all payees 
         * @summary List payees
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budgetId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<PayeesResponse> {
            const localVarFetchArgs = PayeesApiFetchParamCreator(configuration).getPayees(budgetId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * PayeesApi - factory interface
 * @export
 */
export const PayeesApiFactory = function (configuration?: Configuration, fetchFunction?: FetchAPI, basePath?: string) {
    return {
        /**
         * Find a single payee by ID 
         * @summary Single payee
         * @param {string} budgetId - ID of budget
         * @param {string} payeeId - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budgetId: string, payeeId: string, options?: any) {
            return PayeesApiFp(configuration).getPayeeById(budgetId, payeeId, options)(fetchFunction, basePath);
        },
        /**
         * List all payees 
         * @summary List payees
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budgetId: string, options?: any) {
            return PayeesApiFp(configuration).getPayees(budgetId, options)(fetchFunction, basePath);
        },
    };
};

/**
 * PayeesApi - object-oriented interface
 * @export
 * @class PayeesApi
 * @extends {BaseAPI}
 */
export class PayeesApi extends BaseAPI {
    /**
     * Find a single payee by ID 
     * @summary Single payee
     * @param {string} budgetId - ID of budget
     * @param {string} payeeId - ID of payee
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    public getPayeeById(budgetId: string, payeeId: string, options?: any) {
        return PayeesApiFp(this.configuration).getPayeeById(budgetId, payeeId, options)(this.fetchFunction, this.basePath);
    }

    /**
     * List all payees 
     * @summary List payees
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    public getPayees(budgetId: string, options?: any) {
        return PayeesApiFp(this.configuration).getPayees(budgetId, options)(this.fetchFunction, this.basePath);
    }

}

/**
 * ScheduledTransactionsApi - fetch parameter creator
 * @export
 */
export const ScheduledTransactionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find a single scheduled transaction by ID 
         * @summary Single scheduled transaction
         * @param {string} budgetId - ID of budget
         * @param {string} scheduledTransactionId - ID of scheduled transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budgetId: string, scheduledTransactionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getScheduledTransactionById.');
            }
            // verify required parameter 'scheduledTransactionId' is not null or undefined
            if (scheduledTransactionId === null || scheduledTransactionId === undefined) {
                throw new RequiredError('scheduledTransactionId','Required parameter scheduledTransactionId was null or undefined when calling getScheduledTransactionById.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions/{scheduled_transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"scheduled_transaction_id"}}`, encodeURIComponent(String(scheduledTransactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all scheduled transactions 
         * @summary List scheduled transactions
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budgetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getScheduledTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledTransactionsApi - functional programming interface
 * @export
 */
export const ScheduledTransactionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find a single scheduled transaction by ID 
         * @summary Single scheduled transaction
         * @param {string} budgetId - ID of budget
         * @param {string} scheduledTransactionId - ID of scheduled transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budgetId: string, scheduledTransactionId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<ScheduledTransactionDetailResponse> {
            const localVarFetchArgs = ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactionById(budgetId, scheduledTransactionId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * List all scheduled transactions 
         * @summary List scheduled transactions
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budgetId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<ScheduledTransactionSummariesResponse> {
            const localVarFetchArgs = ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactions(budgetId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * ScheduledTransactionsApi - factory interface
 * @export
 */
export const ScheduledTransactionsApiFactory = function (configuration?: Configuration, fetchFunction?: FetchAPI, basePath?: string) {
    return {
        /**
         * Find a single scheduled transaction by ID 
         * @summary Single scheduled transaction
         * @param {string} budgetId - ID of budget
         * @param {string} scheduledTransactionId - ID of scheduled transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budgetId: string, scheduledTransactionId: string, options?: any) {
            return ScheduledTransactionsApiFp(configuration).getScheduledTransactionById(budgetId, scheduledTransactionId, options)(fetchFunction, basePath);
        },
        /**
         * List all scheduled transactions 
         * @summary List scheduled transactions
         * @param {string} budgetId - ID of budget
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budgetId: string, options?: any) {
            return ScheduledTransactionsApiFp(configuration).getScheduledTransactions(budgetId, options)(fetchFunction, basePath);
        },
    };
};

/**
 * ScheduledTransactionsApi - object-oriented interface
 * @export
 * @class ScheduledTransactionsApi
 * @extends {BaseAPI}
 */
export class ScheduledTransactionsApi extends BaseAPI {
    /**
     * Find a single scheduled transaction by ID 
     * @summary Single scheduled transaction
     * @param {string} budgetId - ID of budget
     * @param {string} scheduledTransactionId - ID of scheduled transaction
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    public getScheduledTransactionById(budgetId: string, scheduledTransactionId: string, options?: any) {
        return ScheduledTransactionsApiFp(this.configuration).getScheduledTransactionById(budgetId, scheduledTransactionId, options)(this.fetchFunction, this.basePath);
    }

    /**
     * List all scheduled transactions 
     * @summary List scheduled transactions
     * @param {string} budgetId - ID of budget
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    public getScheduledTransactions(budgetId: string, options?: any) {
        return ScheduledTransactionsApiFp(this.configuration).getScheduledTransactions(budgetId, options)(this.fetchFunction, this.basePath);
    }

}

/**
 * TransactionsApi - fetch parameter creator
 * @export
 */
export const TransactionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all transactions 
         * @summary List transactions
         * @param {string} budgetId - ID of budget
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budgetId: string, sinceDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(sinceDate);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List transactions for an account 
         * @summary List account transactions
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budgetId: string, accountId: string, sinceDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getTransactionsByAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getTransactionsByAccount.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(sinceDate);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List transactions for a category 
         * @summary List category transactions
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budgetId: string, categoryId: string, sinceDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getTransactionsByCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getTransactionsByCategory.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(sinceDate);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a single transaction by ID 
         * @summary Single transaction
         * @param {string} budgetId - ID of budget
         * @param {string} transactionId - ID of transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budgetId: string, transactionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'budgetId' is not null or undefined
            if (budgetId === null || budgetId === undefined) {
                throw new RequiredError('budgetId','Required parameter budgetId was null or undefined when calling getTransactionsById.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionsById.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all transactions 
         * @summary List transactions
         * @param {string} budgetId - ID of budget
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budgetId: string, sinceDate?: Date, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<TransactionSummariesResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactions(budgetId, sinceDate, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * List transactions for an account 
         * @summary List account transactions
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budgetId: string, accountId: string, sinceDate?: Date, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<TransactionSummariesResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsByAccount(budgetId, accountId, sinceDate, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * List transactions for a category 
         * @summary List category transactions
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budgetId: string, categoryId: string, sinceDate?: Date, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<TransactionSummariesResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsByCategory(budgetId, categoryId, sinceDate, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Find a single transaction by ID 
         * @summary Single transaction
         * @param {string} budgetId - ID of budget
         * @param {string} transactionId - ID of transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budgetId: string, transactionId: string, options?: any): (fetchFunction?: FetchAPI, basePath?: string) => Promise<TransactionDetailResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsById(budgetId, transactionId, options);
            return (fetchFunction: FetchAPI = fetch, basePath: string = BASE_PATH) => {
                return fetchFunction(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, fetchFunction?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all transactions 
         * @summary List transactions
         * @param {string} budgetId - ID of budget
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budgetId: string, sinceDate?: Date, options?: any) {
            return TransactionsApiFp(configuration).getTransactions(budgetId, sinceDate, options)(fetchFunction, basePath);
        },
        /**
         * List transactions for an account 
         * @summary List account transactions
         * @param {string} budgetId - ID of budget
         * @param {string} accountId - ID of account
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budgetId: string, accountId: string, sinceDate?: Date, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsByAccount(budgetId, accountId, sinceDate, options)(fetchFunction, basePath);
        },
        /**
         * List transactions for a category 
         * @summary List category transactions
         * @param {string} budgetId - ID of budget
         * @param {string} categoryId - ID of category
         * @param {Date} [sinceDate] - Only return transactions on or after this date
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budgetId: string, categoryId: string, sinceDate?: Date, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsByCategory(budgetId, categoryId, sinceDate, options)(fetchFunction, basePath);
        },
        /**
         * Find a single transaction by ID 
         * @summary Single transaction
         * @param {string} budgetId - ID of budget
         * @param {string} transactionId - ID of transaction
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budgetId: string, transactionId: string, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsById(budgetId, transactionId, options)(fetchFunction, basePath);
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * List all transactions 
     * @summary List transactions
     * @param {string} budgetId - ID of budget
     * @param {Date} [sinceDate] - Only return transactions on or after this date
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(budgetId: string, sinceDate?: Date, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactions(budgetId, sinceDate, options)(this.fetchFunction, this.basePath);
    }

    /**
     * List transactions for an account 
     * @summary List account transactions
     * @param {string} budgetId - ID of budget
     * @param {string} accountId - ID of account
     * @param {Date} [sinceDate] - Only return transactions on or after this date
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsByAccount(budgetId: string, accountId: string, sinceDate?: Date, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsByAccount(budgetId, accountId, sinceDate, options)(this.fetchFunction, this.basePath);
    }

    /**
     * List transactions for a category 
     * @summary List category transactions
     * @param {string} budgetId - ID of budget
     * @param {string} categoryId - ID of category
     * @param {Date} [sinceDate] - Only return transactions on or after this date
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsByCategory(budgetId: string, categoryId: string, sinceDate?: Date, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsByCategory(budgetId, categoryId, sinceDate, options)(this.fetchFunction, this.basePath);
    }

    /**
     * Find a single transaction by ID 
     * @summary Single transaction
     * @param {string} budgetId - ID of budget
     * @param {string} transactionId - ID of transaction
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsById(budgetId: string, transactionId: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsById(budgetId, transactionId, options)(this.fetchFunction, this.basePath);
    }

}
